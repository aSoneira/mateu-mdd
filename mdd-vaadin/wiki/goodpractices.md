Here I will expose some good practices I have learned when using Mateu MDD.

I understand that most of them will be obvious for you, but I think it could be important for someone and I think Mateu MDD manual would not be complete if I do not include this topic.

Some of them are just JPA related good practices, but I think it worths including them in this section.

# General

## toString

Mateu MDD uses the toString() method to set the title of editors and in other places, so it is a good idea to fill it.

If the `toString` method is not overrided then Mateu MDD will infer a title like 'Customer 425'.

## hashCode

The `hashCode` method is used by `HashMaps` to know in which socket must an object be inserted. This is important as, when he looks for an object, he only searchs at the socket where an object is suposed to be.

If `hashCode` changes on some object values then the hashmap will think an object is not present when it actually is, so it can be inserted twice.

````java

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }

````
## equals

The `equals` method is used by sets and maps to know if an object / key is present.

The default equals method generated by lombok is not valid for me, as it returns false when 2 versions of the same entity are compared (and it should only look at the id field). 

Here follows my usual `equals` method for my entities:

````java

    @Override
    public boolean equals(Object obj) {
        return this == obj || 
           (obj != null && obj instanceof  AbstractContract 
               && id == ((AbstractContract)obj).id);
    }


````
 
## sets and lists

The main difference between sets and lists is that elements can appear more than once inside lists, while one object and appear only once inside a set.

This is something more important that it seems, and you should pay some attention to it when creating your classes.

Please note that when using sets you must take care of ordering. 

## maps

Maps are handled by Mateu MDD just as a collection of keys and values.

When using maps pay special attention to hashCode and equals methods for keys, as is they are not properly set the map will have unexpected behaviours.

## cascade and orphan removal

In JPA you have the cascade and orphanRemoval for relations.

Please pay special attention to them and do not merge either persist objects that will anyway be persisted when added to such relations. It can lead to undesired duplicated objects.

## parameters in native queries

In Eclipelink (the default JPA implementation used at Mateu MDD) you can use named parameters with `?` instead of `:`. E.g.:

````java

    @Override
    public Query buildQuery(EntityManager em, boolean forCount) throws Throwable {
        String ql = "";

        ql += " select h.id, h.name, count(*) ";

        ql+= " from booking b inner join hotel h on h.id = b.hotel_id ";

        Map<String, Object> params = new HashMap<>();
        String w = "";

        if (checkInFrom != null) {
            if (!"".equals(w)) w += " and ";
            w += " x.start >= ?s";
            params.put("s", checkInFrom);
        }
        if (checkInTo != null) {
            if (!"".equals(w)) w += " and ";
            w += " x.end <= ?t";
            params.put("t", checkInTo);
        }
        if (hotel != null) {
            if (!"".equals(w)) w += " and ";
            w += " x.hotel.id <= ?h";
            params.put("h", hotel.getId());
        }

        if (!"".equals(w)) ql += " where " + w + " ";



        ql += " group by h.id, h.name ";
        ql += " order by h.name ";

        if (forCount) {
            ql = " select count(*) from (" + ql + ")";
        }

        Query q = em.createNativeQuery(ql);
        params.keySet().forEach(k -> q.setParameter(k, params.get(k)));

        return q;
    }


````


## generated primary keys

For ids annotated with `@GeneratedValue` remember the id is not present until the object is flushed to the database.

## lazy loading

Please remember you can declare fields as lazy, so they will not be loaded until used.

## persist, merge, remove

Please remember that you can persist or merge and object to insert it into your database.

They have different behaviours, anyway.

You can use merge when you want to attach an object to your current entity manager, bot note that it will return a new (attached) object. From that moment you should use this new object, as any change you do to the original object will be discarded unless you merge it again.


## @PrePersist, @PostUpdate, ...

Please not that you should use @Prepersist or @PreUpdate only for throwing exceptions in order to prevent updates of the database, or for updating fields of the object being updated. You can not update fields of other objects as they could be not part of the changeset and they would not be updated in the database.

Use @PostLoad to fill transient fields of your entity, like accumulated values or things like this.

Use @PostPersist, @PostUpdate and @PostRemove only for launching tasks. Do not use them for updating values anywhere, as they would not update the database. If you need to update anything, issue a new transaction.

Here is how I do it:

````java

    @PostPersist@PostUpdate@PostRemove
    public void post() {
        WorkflowEngine.add(new Runnable() {
            @Override
            public void run() {
                try {
                    Helper.transact(em -> em.find(Inventory.class, getInventory().getId()).setBuildPending(true));
                } catch (Throwable throwable) {
                    throwable.printStackTrace();
                }
            }
        });
    }

````

## Exceptions

Pay special attention to Throwable vs Exception vs Error.

Specially when thrown from a @PrePersist or @PreUpdate.

## cloneAsConverted

Create a `cloneAsConverted` method when you change the default Mateu MDD behaviour for duplicating objects.

## createXXInstance

Create a `createXXInstance` method when you want to control the way new objects are added to a collection field by Mateu MDD.

E.g.:

````java

    public Allotment createAllotmentInstance() {
        return new Allotment(this);
    }

````

## @FieldsFilter

Use the `@FiledsFilter` annotation to filter which columns must be shown in a List field.

E.g.:

````java

    @OneToMany(cascade = CascadeType.ALL, mappedBy = "hotelContract")
    @FieldsFilter("date,amount,paid")
    private List<HotelContractDueDate> dueDates = new ArrayList<>();

````


## How to implement triggers in OOP / JPA

I think the most important thing to note is that you can not update other objects from inside @PrePersist/Update methods, and that you can not update anything from @PostPersist/Update/Remove methods UNLESS THEY ARE MARKED AS MERGE CASCADE. This is due to the way change sets are handled by EclipseLink.

Once it is clear for you, you can deal with the problem.

My current approach is to use put code inside setters to update other objects, so these changes become part of the transaction and guarantees that these changes will be persisted.

E.g.:

````java

    public void setAmount(double amount) {
        System.out.println("setAmount(" + amount + ")");
        double previousAmount = this.amount;
        this.amount = amount;
        System.out.println("updating account balance as we have " +
                                                  "changed the amount");
        if (previousAmount != amount) 
            getAccount().setBalance(getAccount().getBalance() 
                                          + amount - previousAmount);
    }

````

For cases when I want to launch a process after one object has been updated, I issue a new transaction from the @PostPersist/Update method.

E.g.:

````java

    @PostPersist@PostUpdate@PostRemove
    public void post() {
        WorkflowEngine.add(new Runnable() {
            @Override
            public void run() {
                try {
                    Helper.transact(em -> em.find(Inventory.class, getInventory().getId()).setBuildPending(true));
                } catch (Throwable throwable) {
                    throwable.printStackTrace();
                }
            }
        });
    }


````



***

Continue with the manual at [Mateu MDD at SonarQube](Sonar).


